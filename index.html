<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Draw Your Character</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    font-family: sans-serif;
    background: #111;
    color: white;
    overflow: hidden;
  }
  #homeScreen, #drawScreen, #levelScreen, #gameScreen {
    display: none;
    height: 100vh;
    width: 100vw;
    box-sizing: border-box;
    padding: 20px;
    text-align: center;
    background: #222;
  }
  #homeScreen.active, #drawScreen.active, #levelScreen.active, #gameScreen.active {
    display: block;
  }
  canvas {
    background: #eef;
    display: block;
    margin: 20px auto;
    border: 2px solid black;
  }
  #controls {
    position: fixed;
    bottom: 15px;
    left: 15px;
    z-index: 10;
  }
  button {
    font-size: 18px;
    margin: 5px;
    padding: 10px 20px;
    border-radius: 8px;
    border: none;
    background: #007acc;
    color: white;
    cursor: pointer;
  }
  button:disabled {
    background: #444;
    cursor: default;
  }
  #levelGrid {
    max-width: 600px;
    margin: 20px auto;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
  }
  .levelBtn {
    width: 60px;
    height: 60px;
    margin: 10px;
    line-height: 60px;
    font-size: 24px;
    border-radius: 10px;
    cursor: pointer;
    user-select: none;
  }
  .unlocked {
    background-color: #00aa00;
  }
  .locked {
    background-color: #555;
    cursor: not-allowed;
    color: #aaa;
  }
</style>
</head>
<body>

<!-- Home -->
<div id="homeScreen" class="active">
  <h1>Draw Your Character</h1>
  <button id="startPlayBtn">Play</button>
  <button id="goToLevelSelectBtn">Level Select</button>
</div>

<!-- Draw -->
<div id="drawScreen">
  <h2>Draw Your Character</h2>
  <canvas id="drawCanvas" width="300" height="300"></canvas>
  <br />
  <button id="finishDrawBtn">Finish Drawing</button>
  <button id="backToHomeFromDrawBtn">Back</button>
</div>

<!-- Level Select -->
<div id="levelScreen">
  <h2>Select Level</h2>
  <div id="levelGrid"></div>
  <button id="backToHomeFromLevelBtn">Back</button>
</div>

<!-- Game -->
<div id="gameScreen">
  <canvas id="gameCanvas"></canvas>
  <div id="controls">
    <button id="leftBtn">‚Üê</button>
    <button id="rightBtn">‚Üí</button>
    <button id="jumpBtn">‚Üë</button>
    <button id="shootBtn">Shoot</button>
  </div>
</div>

<script>
  // DOM Elements
  const homeScreen = document.getElementById('homeScreen');
  const drawScreen = document.getElementById('drawScreen');
  const levelScreen = document.getElementById('levelScreen');
  const gameScreen = document.getElementById('gameScreen');

  const startPlayBtn = document.getElementById('startPlayBtn');
  const goToLevelSelectBtn = document.getElementById('goToLevelSelectBtn');
  const finishDrawBtn = document.getElementById('finishDrawBtn');
  const backToHomeFromDrawBtn = document.getElementById('backToHomeFromDrawBtn');
  const backToHomeFromLevelBtn = document.getElementById('backToHomeFromLevelBtn');

  const levelGrid = document.getElementById('levelGrid');

  const drawCanvas = document.getElementById('drawCanvas');
  const drawCtx = drawCanvas.getContext('2d');

  const gameCanvas = document.getElementById('gameCanvas');
  const ctx = gameCanvas.getContext('2d');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');
  const shootBtn = document.getElementById('shootBtn');

  // Variables and state
  let drawing = false;
  let drawDataURL = null;
  let playerImage = null;

  let keys = { left: false, right: false, up: false };
  let bullets = [];
  let enemies = [];
  let obstacles = [];

  let currentLevel = 1;
  let unlockedLevels = parseInt(localStorage.getItem('unlockedLevels')) || 1;

  // Setup canvas size for game screen
  function resizeGameCanvas() {
    gameCanvas.width = window.innerWidth;
    gameCanvas.height = window.innerHeight;
  }
  resizeGameCanvas();
  window.addEventListener('resize', resizeGameCanvas);

  // --- Screen switching ---
  function showScreen(screen) {
    homeScreen.classList.remove('active');
    drawScreen.classList.remove('active');
    levelScreen.classList.remove('active');
    gameScreen.classList.remove('active');
    screen.classList.add('active');
  }

  // --- Drawing logic ---
  drawCanvas.style.border = "2px solid black";
  drawCtx.fillStyle = 'white';
  drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);

  drawCanvas.addEventListener('mousedown', e => {
    drawing = true;
    drawCtx.beginPath();
    drawCtx.moveTo(e.offsetX, e.offsetY);
  });
  drawCanvas.addEventListener('mousemove', e => {
    if (!drawing) return;
    drawCtx.lineTo(e.offsetX, e.offsetY);
    drawCtx.strokeStyle = 'black';
    drawCtx.lineWidth = 4;
    drawCtx.stroke();
  });
  drawCanvas.addEventListener('mouseup', e => {
    drawing = false;
  });
  drawCanvas.addEventListener('mouseleave', e => {
    drawing = false;
  });

  drawCanvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const rect = drawCanvas.getBoundingClientRect();
    const touch = e.touches[0];
    drawing = true;
    drawCtx.beginPath();
    drawCtx.moveTo(touch.clientX - rect.left, touch.clientY - rect.top);
  });
  drawCanvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!drawing) return;
    const rect = drawCanvas.getBoundingClientRect();
    const touch = e.touches[0];
    drawCtx.lineTo(touch.clientX - rect.left, touch.clientY - rect.top);
    drawCtx.strokeStyle = 'black';
    drawCtx.lineWidth = 4;
    drawCtx.stroke();
  });
  drawCanvas.addEventListener('touchend', e => {
    drawing = false;
  });

  // --- Level Select menu ---
  function drawLevelButtons() {
    levelGrid.innerHTML = '';
    for(let i=1; i<=20; i++){
      const btn = document.createElement('div');
      btn.classList.add('levelBtn');
      if(i <= unlockedLevels){
        btn.classList.add('unlocked');
        btn.textContent = i;
        btn.onclick = () => {
          currentLevel = i;
          if(playerImage) startGame();
          showScreen(gameScreen);
        }
      } else {
        btn.classList.add('locked');
        btn.textContent = 'üîí';
      }
      levelGrid.appendChild(btn);
    }
  }

  // --- Start play button ---
  startPlayBtn.onclick = () => {
    showScreen(drawScreen);
    // Reset drawing canvas
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    drawCtx.fillStyle = 'white';
    drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
    drawDataURL = null;
  };

  goToLevelSelectBtn.onclick = () => {
    drawLevelButtons();
    showScreen(levelScreen);
  };

  backToHomeFromDrawBtn.onclick = () => {
    showScreen(homeScreen);
  };

  backToHomeFromLevelBtn.onclick = () => {
    showScreen(homeScreen);
  };

  // --- Finish drawing ---
  finishDrawBtn.onclick = () => {
    drawDataURL = drawCanvas.toDataURL();
    const img = new Image();
    img.src = drawDataURL;
    img.onload = () => {
      playerImage = img;
      showScreen(levelScreen);
      drawLevelButtons();
    };
  };

  // --- Game Logic ---
  const gravity = 0.7;

  // Player Object
  const player = {
    x: 100,
    y: 0,
    width: 40,
    height: 40,
    dx: 0,
    dy: 0,
    onGround: false,
    facing: 'right',
  };

  function drawPlayer() {
    if (!playerImage) {
      // fallback rectangle
      ctx.fillStyle = 'blue';
      ctx.fillRect(player.x, player.y, player.width, player.height);
      return;
    }

    // Draw only non-transparent pixels (no white box)
    // We do this by drawing playerImage on an offscreen canvas, then
    // copying only pixels that have alpha > 0.

    // We'll just draw the image with ctx.drawImage directly, but since
    // the drawCanvas background is white, it should be transparent outside
    // the lines. To remove the white background, let's convert white pixels
    // to transparent in an offscreen canvas.

    if (!player._maskedImage) {
      const offCanvas = document.createElement('canvas');
      offCanvas.width = playerImage.width;
      offCanvas.height = playerImage.height;
      const offCtx = offCanvas.getContext('2d');
      offCtx.drawImage(playerImage, 0, 0);

      const imgData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
      const data = imgData.data;

      for(let i=0; i < data.length; i +=4){
        const r = data[i];
        const g = data[i+1];
        const b = data[i+2];
        // If pixel is close to white, make transparent
        if(r > 240 && g > 240 && b > 240){
          data[i+3] = 0;
        }
      }
      offCtx.putImageData(imgData,0,0);
      player._maskedImage = new Image();
      player._maskedImage.src = offCanvas.toDataURL();
    }

    if (player.facing === 'right') {
      ctx.drawImage(player._maskedImage, player.x, player.y, player.width, player.height);
    } else {
      ctx.save();
      ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
      ctx.scale(-1, 1);
      ctx.drawImage(player._maskedImage, -player.width / 2, -player.height / 2, player.width, player.height);
      ctx.restore();
    }

    // Draw gun
    ctx.fillStyle = 'black';
    const gunX = player.facing === 'right' ? player.x + player.width : player.x - 10;
    ctx.fillRect(gunX, player.y + 10, 10, 5);
  }

  function drawFlag() {
    ctx.fillStyle = 'green';
    ctx.fillRect(flag.x, flag.y, flag.width, flag.height);
  }

  function drawEnemies() {
    enemies.forEach(e => {
      ctx.font = '40px serif';
      ctx.fillText(e.emoji, e.x, e.y + e.height);
      // Health bar
      ctx.fillStyle = 'red';
      ctx.fillRect(e.x, e.y - 10, (e.hp / 20) * e.width, 5);
    });
  }

  function drawBullets() {
    bullets.forEach(b => {
      ctx.fillStyle = 'black';
      ctx.fillRect(b.x, b.y, 8, 4);
    });
  }

  function drawObstacles() {
    ctx.fillStyle = 'brown';
    obstacles.forEach(o => {
      ctx.fillRect(o.x, o.y, o.width, o.height);
    });
  }

  function applyGravity() {
    player.dy += gravity;
    player.y += player.dy;

    player.onGround = false;

    // Solid platform collision on all platforms
    obstacles.forEach(o => {
      // AABB collision check with y-axis only for ground platforms
      if (
        player.x + player.width > o.x &&
        player.x < o.x + o.width &&
        player.y + player.height <= o.y + player.dy + 1 && // just below top surface?
        player.y + player.height + player.dy >= o.y // falling onto platform
      ) {
        player.y = o.y - player.height;
        player.dy = 0;
        player.onGround = true;
      }
    });

    // Prevent falling below canvas bottom
    if (player.y + player.height > gameCanvas.height) {
      player.y = gameCanvas.height - player.height;
      player.dy = 0;
      player.onGround = true;
    }
  }

  function updatePlayer() {
    if (keys.left) {
      player.dx = -5;
      player.facing = 'left';
    } else if (keys.right) {
      player.dx = 5;
      player.facing = 'right';
    } else {
      player.dx = 0;
    }

    player.x += player.dx;

    // Prevent going out of bounds
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > gameCanvas.width) player.x = gameCanvas.width - player.width;

    applyGravity();
  }

  function updateBullets() {
    bullets.forEach((b, i) => {
      b.x += b.dx;
      // Remove bullets off screen
      if (b.x < 0 || b.x > gameCanvas.width) {
        bullets.splice(i, 1);
        return;
      }
      // Check collision with enemies
      enemies.forEach(e => {
        if (
          b.x < e.x + e.width &&
          b.x + 8 > e.x &&
          b.y < e.y + e.height &&
          b.y + 4 > e.y
        ) {
          e.hp -= 10;
          bullets.splice(i, 1);
        }
      });
    });
    // Remove dead enemies
    enemies = enemies.filter(e => e.hp > 0);
  }

  function updateEnemies() {
    enemies.forEach(e => {
      // Simple AI: Move towards player
      if (e.x + e.width / 2 < player.x + player.width / 2) {
        e.x += 1;
      } else {
        e.x -= 1;
      }
    });
  }

  function checkFlag() {
    if (
      player.x + player.width > flag.x &&
      player.x < flag.x + flag.width &&
      player.y + player.height > flag.y &&
      player.y < flag.y + flag.height
    ) {
      alert('Level Complete! üéâ');
      if(currentLevel === unlockedLevels && unlockedLevels < 20){
        unlockedLevels++;
        localStorage.setItem('unlockedLevels', unlockedLevels);
      }
      showScreen(levelScreen);
      drawLevelButtons();
    }
  }

  function gameLoop() {
    ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

    drawObstacles();
    drawFlag();
    drawPlayer();
    drawEnemies();
    drawBullets();

    updatePlayer();
    updateEnemies();
    updateBullets();
    checkFlag();

    requestAnimationFrame(gameLoop);
  }

  function shoot() {
    const speed = player.facing === 'right' ? 8 : -8;
    const startX = player.facing === 'right' ? player.x + player.width : player.x - 8;
    const startY = player.y + 20;
    bullets.push({ x: startX, y: startY, dx: speed });
  }

  // --- Controls ---
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') keys.left = true;
    if (e.key === 'ArrowRight') keys.right = true;
    if (e.key === 'ArrowUp' && player.onGround) player.dy = -12;
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft') keys.left = false;
    if (e.key === 'ArrowRight') keys.right = false;
  });

  leftBtn.addEventListener('touchstart', e => { keys.left = true; e.preventDefault(); });
  leftBtn.addEventListener('touchend', e => { keys.left = false; e.preventDefault(); });
  rightBtn.addEventListener('touchstart', e => { keys.right = true; e.preventDefault(); });
  rightBtn.addEventListener('touchend', e => { keys.right = false; e.preventDefault(); });
  jumpBtn.addEventListener('touchstart', e => {
    if (player.onGround) player.dy = -12;
    e.preventDefault();
  });
  shootBtn.addEventListener('touchstart', e => { shoot(); e.preventDefault(); });

  // --- Start game ---
  function startGame() {
    player.x = 100;
    player.y = 0;
    player.dx = 0;
    player.dy = 0;
    player.facing = 'right';
    bullets = [];

    // Setup enemies and obstacles based on level
    // Customize more later for more obstacles or enemy types
    enemies = [
      { x: 600, y: 460 - 40, width: 40, height: 40, hp: 20, emoji: 'üëΩ' },
      { x: 700, y: 460 - 40, width: 40, height: 40, hp: 20, emoji: 'üòà' },
      { x: 800, y: 460 - 40, width: 40, height: 40, hp: 20, emoji: 'üëπ' }
    ];

    obstacles = [
      { x: 0, y: gameCanvas.height - 40, width: gameCanvas.width, height: 40 },
      { x: 300, y: gameCanvas.height - 80, width: 200, height: 20 }
    ];

    flag = { x: gameCanvas.width - 60, y: gameCanvas.height - 100, width: 30, height: 60 };

    gameLoop();
  }

</script>

</body>
</html>
